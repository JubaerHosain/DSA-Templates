class Solution {
private:
    vector<int> prnt, rnk;

    int find(int u) {
        if(prnt[u] == -1) return u;
        return prnt[u] = find(prnt[u]);
    }

    void merge(int u, int v) {
        u = find(u);
        v = find(v);
        
        if(u == v)
            return;

        if(rnk[u] < rnk[v]) swap(u, v);

        rnk[u] += rnk[v];
        prnt[v] = u;
    }
    
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        rnk = vector<int>(n, 1);
        prnt = vector<int>(n, -1);
        
        vector<bool> infected(n, false);
        for(int u: initial)
            infected[u] = true;
        
        // make groups without infected nodes
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(graph[i][j] == 0 || infected[i] || infected[j]) 
                    continue;
                merge(i, j);
            }
        }
        
        // number of infected adjacent for this group
        vector<int> prnt_cnt(n, 0);
        vector<bool> tmp(n, false);
        
        for(int u: initial) {
            for(int i = 0; i < n; i++)
                tmp[i] = false;
            
            for(int j = 0; j < n; j++) {
                int p = find(j);
                if(graph[u][j] == 1 && u != j && !infected[j] && !tmp[p]) {
                    prnt_cnt[p] += 1;
                    tmp[p] = true;
                }
                    
            }
        }
        
        int ans = n+1;
        int mx = -1, mn = n+1;
        for(int i: initial) {
            mn = min(mn, i);
            int tot = 0;
            
            // should not count a group size multiple time
            for(int i = 0; i < n; i++)
                tmp[i] = false;
            
            for(int j = 0; j < n; j++) {
                if(i == j)
                    continue;
                int u = find(j);
                if(graph[i][j] == 1 && !infected[j] && prnt_cnt[u] <= 1 && !tmp[u]) {
                    tot += rnk[u];
                    tmp[u] = true;
                }
            }
            
            if(tot > mx) {
                mx = tot;
                ans = i;
            } else if(tot == mx) {
                ans = min(ans, i);
            }
        }
        
        if(ans == n+1)
            return mn;
        
        return ans;
    }
};

